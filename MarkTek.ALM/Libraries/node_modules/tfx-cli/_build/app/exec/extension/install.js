"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var args = require("../../lib/arguments");
var extBase = require("./default");
var extInfo = require("./_lib/extensioninfo");
var Q = require("q");
var trace = require("../../lib/trace");
var GalleryInterfaces = require("vso-node-api/interfaces/GalleryInterfaces");
var SPS_INSTANCE_TYPE = "951917AC-A960-4999-8464-E3F0AA25B381";
function getCommand(args) {
    return new ExtensionInstall(args);
}
exports.getCommand = getCommand;
var AccountInstallReport = (function () {
    function AccountInstallReport(itemId, accountName, accountId, installed, reason) {
        if (installed === void 0) { installed = false; }
        this.itemId = itemId;
        this.accountName = accountName;
        this.accountId = accountId;
        this.installed = installed;
        this.reason = reason;
    }
    AccountInstallReport.prototype.setError = function (reason) {
        this.installed = false;
        this.reason = reason;
    };
    AccountInstallReport.prototype.setInstalled = function (reason) {
        this.installed = true;
        this.reason = reason;
    };
    return AccountInstallReport;
}());
exports.AccountInstallReport = AccountInstallReport;
var ExtensionInstallResult = (function () {
    function ExtensionInstallResult(itemId, accountReports) {
        this.itemId = itemId;
        this.accountReports = accountReports;
    }
    ExtensionInstallResult.prototype.hasErrors = function () {
        return this.accountReports.some(function (t) { return !t.installed; });
    };
    ExtensionInstallResult.prototype.toString = function () {
        var result;
        var status = this.hasErrors() ? "Failed" : "Succeeded";
        result = ("=== Installation " + status + " === ") +
            ("\n  - ItemId: " + this.itemId) +
            "\n  - Accounts:";
        this.accountReports.forEach(function (t) {
            result += "\n\t- " + t.accountName + ": [" + (t.installed ? "OK" : "Failed: " + t.reason) + "]";
        });
        return result;
    };
    return ExtensionInstallResult;
}());
exports.ExtensionInstallResult = ExtensionInstallResult;
var ExtensionInstall = (function (_super) {
    __extends(ExtensionInstall, _super);
    function ExtensionInstall(passedArgs) {
        _super.call(this, passedArgs);
        this.description = "Install a Visual Studio Services Extension to a list of VSTS Accounts.";
    }
    ExtensionInstall.prototype.setCommandArgs = function () {
        _super.prototype.setCommandArgs.call(this);
        this.registerCommandArgument("accounts", "Installation target accounts", "List of accounts where to install the extension.", args.ArrayArgument);
    };
    ExtensionInstall.prototype.getHelpArgs = function () {
        return ["publisher", "extensionId", "vsix", "accounts"];
    };
    ExtensionInstall.prototype.exec = function () {
        var _this = this;
        // Read extension info from arguments
        return this._getExtensionInfo()
            .then(function (extInfo) {
            var itemId = extInfo.publisher + "." + extInfo.id;
            var galleryApi = _this.webApi.getQGalleryApi(_this.webApi.serverUrl);
            // Read accounts from arguments and resolve them to get its accountIds
            return _this.commandArgs.accounts.val()
                .then(function (accounts) {
                return _this._resolveInstallationAccounts(galleryApi, accounts);
            })
                .then(function (accounts) {
                // Install extension in each account
                var installations = accounts.slice().map(function (account) { return _this._installExtension(galleryApi, itemId, account.accountId, account.accountName); });
                return Q.all(installations);
            })
                .then(function (targetReports) {
                // Process installation results. We reject if exists at least one that was not installed successfully
                var result = new ExtensionInstallResult(itemId, targetReports);
                if (result.hasErrors()) {
                    return Q.reject(result);
                }
                // All succeeded. Return resolved.
                return result;
            });
        });
    };
    ExtensionInstall.prototype.friendlyOutput = function (data) {
        trace.success("\n=== Completed operation: install extension ===");
        trace.info(" - Installed extension " + data.itemId + " in:");
        if (data.accountReports && data.accountReports.length > 0) {
            data.accountReports.forEach(function (report) {
                trace.info("   - " + report.accountName);
            });
        }
        else {
            trace.info("No accounts specified");
        }
    };
    ExtensionInstall.prototype._getExtensionInfo = function () {
        var _this = this;
        return this.commandArgs.vsix.val(true).then(function (vsixPath) {
            var extInfoPromise;
            if (vsixPath !== null) {
                extInfoPromise = extInfo.getExtInfo(vsixPath[0], null, null);
            }
            else {
                extInfoPromise = Q.all([
                    _this.commandArgs.publisher.val(),
                    _this.commandArgs.extensionId.val()]).spread(function (publisher, extension) {
                    return extInfo.getExtInfo(null, extension, publisher);
                });
            }
            return extInfoPromise;
        });
    };
    ExtensionInstall.prototype._resolveInstallationAccounts = function (galleryApi, accounts) {
        var _this = this;
        if (!accounts || accounts.length === 0) {
            return Q.resolve([]);
        }
        var result = Q.defer();
        // Use connectionData service to determine userId
        trace.debug("Connecting to service to get user");
        galleryApi.connect()
            .then(function (data) {
            if (!data || !data.authenticatedUser || !data.authenticatedUser.id) {
                throw new Error("Cannot determine authenticated user in order to resolve accounts for which is an owner or a member of.");
            }
            trace.debug("Installation User Id:" + data.authenticatedUser.id);
            return _this._getAccountsByMemberId(data.authenticatedUser.id);
        })
            .then(function (userAccounts) {
            var getAccountId = function (accountName) {
                var resolvedAccount = userAccounts.filter(function (a) { return a.accountName.toLowerCase() === accountName.toLowerCase(); });
                return resolvedAccount && resolvedAccount.length > 0 ? resolvedAccount[0].accountId : undefined;
            };
            return result.resolve(accounts.map(function (accountName) { return { accountId: getAccountId(accountName), accountName: accountName }; }));
        })
            .fail(function (err) {
            result.reject(err);
        });
        return result.promise;
    };
    ExtensionInstall.prototype._installExtension = function (galleryApi, itemId, accountId, accountName) {
        var _this = this;
        var accountReport = new AccountInstallReport(itemId, accountName, accountId);
        if (!accountId) {
            accountReport.setError("Cannot install extension into account " + accountName + " because is not an acccount for which the installation user is owner or a member of.");
            return Q.resolve(accountReport);
        }
        return galleryApi.requestAcquisition({
            assignmentType: GalleryInterfaces.AcquisitionAssignmentType.None,
            billingId: null,
            itemId: itemId,
            operationType: GalleryInterfaces.AcquisitionOperationType.Install,
            targets: [accountId]
        })
            .then(function (report) {
            trace.debug("Succeeded GalleryApi.requestAcquisition in " + accountName + ": " + report);
            accountReport.installed = true;
            return accountReport;
        })
            .fail(function (err) {
            // Ignore error 'AlreadyInstalled'
            if (_this._isAlreadyInstalledError(err)) {
                trace.debug("Succeeded GalleryApi.requestAcquisition in " + accountName + ": Already installed");
                accountReport.setInstalled("Extension already installed");
                return accountReport;
            }
            trace.error("Failed GalleryApi.requestAcquisition for account " + accountName + ": " + err);
            accountReport.setError(err);
            return accountReport;
        });
    };
    ExtensionInstall.prototype._isAlreadyInstalledError = function (err) {
        // 409 - Conflict: means extension already installed
        return err.statusCode === 409;
    };
    ExtensionInstall.prototype._getAccountsByMemberId = function (userId) {
        var _this = this;
        trace.debug("Getting Accounts to user:" + userId);
        return this._getAccountsServiceBaseUrl()
            .then(function (accountsBaseUrl) {
            var accountsApi = new AccountsApi(accountsBaseUrl, [_this.webApi.authHandler]);
            return accountsApi.getAccounts(undefined, undefined, userId);
        });
    };
    /**
     * Determine the Accounts URL based by using the Location Service.
     *
     * @param  {string} serviceUrl
     * @returns string
     */
    ExtensionInstall.prototype._getAccountsServiceBaseUrl = function () {
        trace.debug("Resolving SPS URL");
        var locationsApi = new LocationsApi(this.webApi.serverUrl, [this.webApi.authHandler]);
        return locationsApi.getServiceDefinition("LocationService2", SPS_INSTANCE_TYPE)
            .then(function (serviceDefinition) {
            var publicMapping = serviceDefinition.locationMappings.filter(function (l) { return l.accessMappingMoniker === "PublicAccessMapping"; });
            if (!publicMapping || publicMapping.length === 0) {
                throw new Error("Cannot determine base URL for Accounts service.");
            }
            trace.debug("SPS URL resolved: " + publicMapping[0].location);
            return publicMapping[0].location;
        });
    };
    return ExtensionInstall;
}(extBase.ExtensionBase));
exports.ExtensionInstall = ExtensionInstall;
var ClientApiBases_1 = require("vso-node-api/ClientApiBases");
/**
 * --------------
 *  ACCOUNTS API (TODO: REMOVE IT AS SOON AS IT IS INCLUDED IN VSO-NODE-API)
 * --------------
 */
var AccountStatus;
(function (AccountStatus) {
    AccountStatus[AccountStatus["None"] = 0] = "None";
    /**
     * This hosting account is active and assigned to a customer.
     */
    AccountStatus[AccountStatus["Enabled"] = 1] = "Enabled";
    /**
     * This hosting account is disabled.
     */
    AccountStatus[AccountStatus["Disabled"] = 2] = "Disabled";
    /**
     * This account is part of deletion batch and scheduled for deletion.
     */
    AccountStatus[AccountStatus["Deleted"] = 3] = "Deleted";
})(AccountStatus || (AccountStatus = {}));
var AccountType;
(function (AccountType) {
    AccountType[AccountType["Personal"] = 0] = "Personal";
    AccountType[AccountType["Organization"] = 1] = "Organization";
})(AccountType || (AccountType = {}));
var AccountsApi = (function (_super) {
    __extends(AccountsApi, _super);
    function AccountsApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, "tfx-cli");
    }
    AccountsApi.prototype.getAccounts = function (creatorId, ownerId, memberId, includeOwner, properties, includeDisabledAccounts) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, accounts) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(accounts);
            }
        };
        var queryValues = {
            creatorId: creatorId,
            ownerId: ownerId,
            memberId: memberId,
            includeOwner: includeOwner,
            properties: properties,
            includeDisabledAccounts: includeDisabledAccounts,
        };
        this.vsoClient.getVersioningData("2.0", "account", "229a6a53-b428-4ffb-a835-e8f36b5b4b1e", null, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    return AccountsApi;
}(ClientApiBases_1.ClientApiBase));
/**
 * ---------------
 *  LOCATIONS API (TODO: REMOVE IT AS SOON AS IT IS INCLUDED IN VSO-NODE-API)
 * ---------------
 */
var InheritLevel;
(function (InheritLevel) {
    InheritLevel[InheritLevel["None"] = 0] = "None";
    InheritLevel[InheritLevel["Deployment"] = 1] = "Deployment";
    InheritLevel[InheritLevel["Account"] = 2] = "Account";
    InheritLevel[InheritLevel["Collection"] = 4] = "Collection";
    InheritLevel[InheritLevel["All"] = 7] = "All";
})(InheritLevel || (InheritLevel = {}));
var RelativeToSetting;
(function (RelativeToSetting) {
    RelativeToSetting[RelativeToSetting["Context"] = 0] = "Context";
    RelativeToSetting[RelativeToSetting["WebApplication"] = 2] = "WebApplication";
    RelativeToSetting[RelativeToSetting["FullyQualified"] = 3] = "FullyQualified";
})(RelativeToSetting || (RelativeToSetting = {}));
var ServiceStatus;
(function (ServiceStatus) {
    ServiceStatus[ServiceStatus["Assigned"] = 0] = "Assigned";
    ServiceStatus[ServiceStatus["Active"] = 1] = "Active";
    ServiceStatus[ServiceStatus["Moving"] = 2] = "Moving";
})(ServiceStatus || (ServiceStatus = {}));
var LocationsApi = (function (_super) {
    __extends(LocationsApi, _super);
    function LocationsApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, "tfx-cli");
    }
    LocationsApi.prototype.getServiceDefinition = function (serviceType, identifier) {
        var _this = this;
        var deferred = Q.defer();
        var onResult = function (err, statusCode, serviceDefinition) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(serviceDefinition);
            }
        };
        var routeValues = {
            serviceType: serviceType,
            identifier: identifier
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
        return deferred.promise;
    };
    return LocationsApi;
}(ClientApiBases_1.ClientApiBase));
